.text                        #вариант 13: нахождение минимального элемента массива
__start:
.globl __start             # программа
       la a2, array_length #}
       lw a2, 0(a2)        #}записываем в a2 длину массива
       
       la a3, array        # записываем в a3 адрес первого элемента массива
       
       call min_element
       
       li a0,10            #}
       ecall               #} если a0 = 10 => ecall выполняет останову
       
.rodata
array_length:
     .word 10              # длина массива
array:                     # массив
     .word 8,6,8,6,5,6,8,3,6,7
     
.text
min_element:
.globl min_element         # подпрограмма
       addi a2,a2,-1  # отнимает 1 от длины массива
       lw a4, 0(a3)  # загружаем в a4 значение первого элемента
       addi a3,a3,4  # создаем адрес следующего элемента

loop:                      # начало цикла
       beqz a2, return     # если a2 = 0 то выходим из цикла и завершаем выполнение программы
       lw t1, 0(a3)        # записываем в t1 значение текущего элемента массива
       addi a2,a2,-1       # отнимаем от длины массива 1
       bltu t1, a4, new_min# если t1 < a4 то записываем новый минимальный элемент массива
       addi a3,a3,4        # создаем адрес следующего элемента
       jal zero, loop      # переход в начало цикла
       
new_min:                   # запись нового минимального элемента массива
       lw a4, 0(a3)        # записываем в a4 текущий элемент массива
       addi a3, a3, 4      # создаем адрес следующего элемента
       jal zero,loop       # переход в начало цикла

return:
       ret