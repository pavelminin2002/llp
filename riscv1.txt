.text                        #вариант 13: нахождение минимального элемента массива
__start:
.globl __start
       la a2, array_length #}
       lw a2, 0(a2)        #}записываем в a2 длину массива
       addi a2,a2,-1       # отнимаем 1 от длины массива, так как сразу рассмотрим его первый элемент
       
       la a3, array        # записываем в a3 адрес первого элемента массива
       lw a4, 0(a3)        # загружаем в a4 значение первого элемента
       addi a3,a3,4        # создаем адрес следующего элемента
       
loop:                      # начало цикла
       beqz a2, exit_loop  # если a2 = 0 то выходим из цикла и завершаем выполнение программы
       lw t1, 0(a3)        # записываем в t1 значение текущего элемента массива
       addi a2,a2,-1       # отнимаем от длины массива 1
       bltu t1, a4, new_min# если t1 < a4 то записываем новый минимальный элемент массива
       addi a3,a3,4        # создаем адрес следующего элемента
       jal zero, loop      # переход в начало цикла
exit_loop:           

finish:
       li a0,10            #}
       ecall               #} если a0 = 10 => ecall выполняет останову
       
new_min:                   # запись нового минимального элемента массива
       lw a4, 0(a3)        # записываем в a4 текущий элемент массива
       addi a3, a3, 4      # создаем адрес следующего элемента
       jal zero,loop       # переход в начало цикла
       
.rodata
array_length:
     .word 10              # длина массива
array:                       # массив
     .word 8,6,8,6,5,6,8,4,6,7